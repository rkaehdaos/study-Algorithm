# heap study
'''
힙 : 최소/쵀대값을 빠르게 찾기 위한 완전 이진 트리
완전 이진 트리 :  노드 삽입시 좌측 최하단 부터
힙 사용 이유
- 배열 사용시 최대/최소값 찾으려면 ? O(n)
- 힙의 경우 O(logn)
- 우선 순위 큐같이 최소/최대값을 빨리 찾아야하는 자료구조/알고리즘에 사용

BST랑 차이
- BST는 왼쪽이 작은 값, 우측이 큰값임
- Heap은 각 노드의 값이 자식 보다 크거나 같음(Max Heap)인 경우
- BST는 탐색, Heap은 최소/최대를 찾기 위한 구조


삽입
- 왼쪽 최하단부터 삽입
- 부모보다 큰 경우 부모와 스왑 x 반복

삭제
- 최상단 삭제가 일반적 : Heap 자체가 최소/최대값을 최상단에 놓아서 바로 꺼내 쓸 수 있게 하는 거
- 최상단 삭제시 "가장 마지막에 추가한 노드"를 root로 이동
- root가 child보다 작을 경우 child중 큰 child와 swap x 반복


구현
- 배열을 활용 : 뜬근없음 - > 완전 이진 트리이기 떄문
- 배열은 0부터 인덱스 시작 -> 1부터 시작하게 만들어야 복잡도가 쉬어짐
  따로 +1 하지말고 첫 데이터를 None으로 집어 넣으면 된다
  이 경우 len()을 쓰면 항상 None까지 해서 실제 데이터+1로 확인됨을 유의
- 부모의 인덱스 번호 = 자식 노드의 인덱스 //2 몫
- 왼쪽 자식 인덱스 번호 = 부모 인덱스 * 2
- 오른쪽 자식 인덱스 번호 = 부모 인데스 * 2 +1


삽입한 데이터 인덱스 : len(array)-1


시간복잡도
- 최악의 경우 root->leaf -> O(logn)




'''